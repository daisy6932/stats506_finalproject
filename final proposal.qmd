---
title: "final project proposal"
format: html
editor: visual
---

```{r}
############################################################
# 0. Packages
############################################################

library(haven)
library(dplyr)
library(forcats)
library(ggplot2)
library(MASS)     # polr()
library(broom)    # tidy()
library(scales)   # percent_format()
library(tidyr)    # pivot_longer, drop_na
library(ggeffects) # ggpredict() for marginal effects


############################################################
# 1. Read three separate datasets
############################################################

# Each .dta file corresponds to one GSS cross-section
gss18 <- read_dta("GSS2018.dta") %>% mutate(year = 2018)
gss21 <- read_dta("GSS2021.dta") %>% mutate(year = 2021)
gss22 <- read_dta("GSS2022.dta") %>% mutate(year = 2022)


############################################################
# 2. Harmonize coding BEFORE combining
############################################################

# In some years, 'happy' and 'health' are stored as numeric
# codes with labels. We force them into consistent ordered
# factor scales using the numeric codes 1,2,3,(4).
convert_happy <- function(x){
  x <- as.numeric(x)
  factor(
    x,
    levels = c(1, 2, 3),
    labels = c("very happy", "pretty happy", "not too happy"),
    ordered = TRUE
  )
}

convert_health <- function(x){
  x <- as.numeric(x)
  factor(
    x,
    levels = c(1, 2, 3, 4),
    labels = c("excellent", "good", "fair", "poor"),
    ordered = TRUE
  )
}

# Cleaning function applied separately to each year.
# It:
#  - recodes happy & health
#  - converts socio-demographic variables to factors
#  - builds a numeric income variable
#  - constructs a survey weight (different for 2022)
clean_one <- function(df, year_value){

  df <- df %>%
    mutate(
      # Harmonized ordered outcomes
      happy  = convert_happy(happy),
      health = convert_health(health),

      # Key covariates as factors
      sex    = as_factor(sex),
      degree = as_factor(degree),
      marital= as_factor(marital),
      race   = as_factor(race),

      # Numeric income, using realinc (inflation-adjusted)
      income_num = as.numeric(realinc),

      # Store year as factor
      year = factor(year_value)
    )

  # Survey weights differ by year.
  # For 2018 and 2021 we use wtssnrps.
  # For 2022 we prioritize wtssps_next / wtssnrps_next and fall back
  # to wtssps / wtssnrps if needed.
  if (year_value == 2022) {
    df <- df %>%
      mutate(
        weight = coalesce(
          as.numeric(wtssps_next),
          as.numeric(wtssnrps_next),
          as.numeric(wtssps),
          as.numeric(wtssnrps)
        )
      )
  } else {
    df <- df %>%
      mutate(
        weight = as.numeric(wtssnrps)
      )
  }

  return(df)
}


############################################################
# 3. Apply cleaning to each year and stack
############################################################

gss18 <- clean_one(gss18, 2018)
gss21 <- clean_one(gss21, 2021)
gss22 <- clean_one(gss22, 2022)

# Combine all three waves
gss_clean <- bind_rows(gss18, gss21, gss22) %>%
  mutate(
    # Binary indicators for descriptive summaries
    very_happy  = happy == "very happy",
    good_health = health %in% c("good", "excellent")
  )

# Drop records with missing survey weight (cannot be used in weighted stats)
gss_clean <- gss_clean %>%
  filter(!is.na(weight))


############################################################
# 4. Weighted summary by year (descriptive trends)
############################################################

summary_year <- gss_clean %>%
  group_by(year) %>%
  summarise(
    prop_very_happy  = weighted.mean(very_happy,  weight, na.rm = TRUE),
    prop_good_health = weighted.mean(good_health, weight, na.rm = TRUE),
    .groups = "drop"
  )

print(summary_year)


############################################################
# 5. Plot: joint trends in happiness and health
############################################################

# Long format for plotting both series in one figure
summary_year_long <- summary_year %>%
  pivot_longer(
    cols = starts_with("prop"),
    names_to = "indicator",
    values_to = "value"
  )

p_trends <- ggplot(summary_year_long,
                   aes(x = year, y = value,
                       group = indicator, color = indicator)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Weighted Trends in Happiness and Health (2018â€“2022)",
    x = "Year",
    y = "Weighted proportion",
    color = ""
  ) +
  theme_minimal(base_size = 14)

ggsave("fig_trends_happy_health.png", p_trends,
       width = 7, height = 4.5, dpi = 300)


############################################################
# 6. Income groups (tertiles) + keep 'Unknown' instead of dropping
############################################################

# Compute income tertiles using all available income_num
qs <- quantile(
  gss_clean$income_num,
  probs = c(0, 1/3, 2/3, 1),
  na.rm = TRUE
)

# Guard against duplicated breakpoints
qs <- unique(qs)
if (length(qs) < 4) {
  qs <- seq(
    from = min(gss_clean$income_num, na.rm = TRUE),
    to   = max(gss_clean$income_num, na.rm = TRUE),
    length.out = 4
  )
}

gss_clean <- gss_clean %>%
  mutate(
    income_group = cut(
      income_num,
      breaks = qs,
      labels = c("low", "middle", "high"),
      include.lowest = TRUE
    ),
    # Missing income becomes an explicit category 'Unknown'
    income_group = fct_explicit_na(income_group, "Unknown"),

    # Recreate binary flags (still useful later)
    very_happy  = happy == "very happy",
    good_health = health %in% c("excellent", "good")
  )

# Check final weighted summary once more (should match earlier)
summary_year <- gss_clean %>%
  group_by(year) %>%
  summarise(
    prop_very_happy  = weighted.mean(very_happy,  weight, na.rm = TRUE),
    prop_good_health = weighted.mean(good_health, weight, na.rm = TRUE),
    .groups = "drop"
  )

print(summary_year)


############################################################
# 7. Prepare data for ordered logistic regression
############################################################

# Keep only valid outcome categories and non-missing weights
model_data <- gss_clean %>%
  filter(
    happy %in% c("very happy", "pretty happy", "not too happy"),
    health %in% c("excellent", "good", "fair", "poor"),
    !is.na(weight)
  ) %>%
  droplevels()

# Collapse rare categories in sex, marital status, and race
# to avoid sparse dummy problems in the polr() estimation.
model_data <- model_data %>%
  mutate(
    # Sex: male/female/other
    sex = fct_collapse(
      sex,
      male   = "male",
      female = "female",
      other  = setdiff(levels(sex), c("male", "female"))
    ),

    # Marital: five main categories + 'other'
    marital = fct_collapse(
      marital,
      married = "married",
      widowed = "widowed",
      divorced = "divorced",
      separated = "separated",
      never   = "never married",
      other   = setdiff(
        levels(marital),
        c("married", "widowed", "divorced", "separated", "never married")
      )
    ),

    # Race: white, black, other
    race = fct_collapse(
      race,
      white = "white",
      black = "black",
      other = setdiff(levels(race), c("white", "black"))
    )
  )

# Set the ordering of the response factors explicitly.
# For happiness: "not too happy" < "pretty happy" < "very happy"
model_data$happy <- fct_relevel(
  model_data$happy,
  "not too happy", "pretty happy", "very happy"
)

# For health: "poor" < "fair" < "good" < "excellent"
model_data$health <- fct_relevel(
  model_data$health,
  "poor", "fair", "good", "excellent"
)


############################################################
# 8. Ordered logistic regression models
############################################################

# Happiness model
model_happy <- polr(
  happy ~ year + sex + age + degree + marital + race + income_group,
  data    = model_data,
  weights = weight,
  Hess    = TRUE
)

# Health model
model_health <- polr(
  health ~ year + sex + age + degree + marital + race + income_group,
  data    = model_data,
  weights = weight,
  Hess    = TRUE
)

summary(model_happy)
summary(model_health)


############################################################
# 9. Tidy model output and save as CSV
############################################################

res_happy  <- tidy(model_happy,  conf.int = TRUE, exponentiate = TRUE)
res_health <- tidy(model_health, conf.int = TRUE, exponentiate = TRUE)

write.csv(res_happy,  "model_happy_clean.csv",  row.names = FALSE)
write.csv(res_health, "model_health_clean.csv", row.names = FALSE)


############################################################
# 10. Marginal effects plots (for the paper)
############################################################

# 10.1: Predicted probabilities by income group (happiness)
pred_income_happy <- ggpredict(model_happy, terms = "income_group")
p_income_happy <- plot(pred_income_happy) +
  labs(
    title = "Predicted probabilities of happiness levels by income group",
    x = "Income group",
    y = "Predicted probability"
  )

ggsave("fig_happy_income_group.png",
       p_income_happy, width = 7, height = 4.5, dpi = 300)


# 10.2: Predicted probabilities by year (happiness)
pred_year_happy <- ggpredict(model_happy, terms = "year")
p_year_happy <- plot(pred_year_happy) +
  labs(
    title = "Predicted probabilities of happiness levels by year",
    x = "Year",
    y = "Predicted probability"
  )

ggsave("fig_happy_by_year.png",
       p_year_happy, width = 7, height = 4.5, dpi = 300)


# 10.3: Predicted probabilities of health by income group
pred_income_health <- ggpredict(model_health, terms = "income_group")
p_income_health <- plot(pred_income_health) +
  labs(
    title = "Predicted probabilities of health levels by income group",
    x = "Income group",
    y = "Predicted probability"
  )

ggsave("fig_health_income_group.png",
       p_income_health, width = 7, height = 4.5, dpi = 300)


############################################################
# END OF SCRIPT
############################################################
```
